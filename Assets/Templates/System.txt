using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
$USINGS$

namespace $NAMESPACE$.Systems
{
	public class $NAME$ : SystemBase
	{
		#$STRUCTURAL_CHANGES
		private EndSimulationEntityCommandBufferSystem _endSimulationCmdBuffer;
		$#STRUCTURAL_CHANGES

		protected override void OnCreate()
		{
			base.OnCreate();
			#$STRUCTURAL_CHANGES
			_endSimulationCmdBuffer = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
			$#STRUCTURAL_CHANGES
		}
		

		protected override void OnUpdate()
		{
			// Assign values to local variables captured in your job here, so that it has everything it
			// needs to do its work when it runs later. For example, float deltaTime = Time.DeltaTime;

			// This declares a new kind of job, which is a unit of work to do. The job is declared as an
			// Entities.ForEach with the target components as parameters, meaning it will process all
			// entities in the world that have both Translation and Rotation components. Change it to
			// process the component types you want.

			#$STRUCTURAL_CHANGES
			var transitionCmdBuffer = _endSimulationCmdBuffer.CreateCommandBuffer();
			$#STRUCTURAL_CHANGES

			#$LAMBDA
			Entities
				.WithName( "$LAMBDA_NAME$" )
				$WITH_ALL$
				$WITH_ANY$
				$WITH_NONE$
				.ForEach( ( #$TRANSITION Entity e, $#TRANSITION $FOR_EACH$ ) =>
			{
				#$TRANSITION
				//TODO: Make transition to one of the following state:
				//$TRANSITION_TO$
				$#TRANSITION
				#$!TRANSITION
				//TODO: Implement state behavior
				$#!TRANSITION
			} ).Schedule();
			$#LAMBDA

			#$STRUCTURAL_CHANGES
			_endSimulationCmdBuffer.AddJobHandleForProducer( this.Dependency );
			$#STRUCTURAL_CHANGES
		}
	}
}